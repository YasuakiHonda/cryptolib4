import Init.Data.BitVec.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.ZMod.Basic
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.Algebra.Group.Subgroup.ZPowers.Basic
import Mathlib.Probability.ProbabilityMassFunction.Basic
import Mathlib.Probability.ProbabilityMassFunction.Monad
import Mathlib.Probability.ProbabilityMassFunction.Constructions


noncomputable section

instance : Monad PMF where
  pure := PMF.pure
  bind := PMF.bind

instance : LawfulFunctor PMF where
  id_map := PMF.map_id
  comp_map := fun f g x => (PMF.map_comp f x g).symm
  map_const := rfl

instance : LawfulMonad PMF where
  pure_bind := PMF.pure_bind
  bind_assoc := PMF.bind_bind
  bind_pure_comp := PMF.bind_pure_comp
  bind_map := fun _ _ => rfl

lemma range_pos_ne_zero (n : ℕ) (n_pos : 0 < n) : Multiset.range n ≠ 0 := by
  apply (Multiset.card_pos).mp
  rw [Multiset.card_range]
  exact n_pos


-- Every element in the cyclic group is generated by the powers of g
def IsCyclic.generator {G : Type} [Group G] [IsCyclic G] (g : G) : Prop :=
  ∀ (x : G), x ∈ Subgroup.zpowers g


namespace Bitvec

def bitVecEquivFin (n : ℕ) : BitVec n ≃ Fin (2^n) where
  toFun := BitVec.toFin  -- BitVec → Fin
  invFun := BitVec.ofFin  -- Fin → BitVec
  left_inv := by
    intro bv
    simp
  right_inv := by
    intro f
    simp

instance (n : ℕ) : Fintype (BitVec n) :=
  Fintype.ofEquiv (Fin (2^n)) (bitVecEquivFin n).symm

lemma card (n : ℕ) : Fintype.card (BitVec n) = 2^n := by
  calc
    Fintype.card (BitVec n)
    = Fintype.card (Fin (2^n)) := Fintype.card_congr (bitVecEquivFin n)
    _= 2^n                  := Fintype.card_fin _


lemma multiset_ne_zero (n : ℕ) : (@Fintype.elems (BitVec n)).val ≠ 0 := by
  apply (Multiset.card_pos).mp
  have h : Multiset.card ((@Fintype.elems (BitVec n)).val) = 2^n := Bitvec.card n
  rw [h]
  simp

end Bitvec


namespace ZMod

-- 0 < n fact not needed... will keep in case of future uses
instance : ∀ (n : ℕ) [NeZero n], Group (ZMod n) := fun
  | .zero => Multiplicative.group
  | .succ _ => Multiplicative.group

-- instance : ∀ (n : ℕ) [Fact (0 < n)], Group (ZMod n) := fun
--   | .zero => Multiplicative.group
--   | .succ _ => Multiplicative.group

end ZMod


-- In Lupo's code, the mem_zpowers_iff lemma is already implemented in Mathlib

-- This is division algorithm... is it already implemented?
lemma exists_mod_add_div (a b : ℕ) : ∃ (m : ℕ), a = a % b + b * m := by
  use (a/b)
  exact (Nat.mod_add_div a b).symm


variable (G : Type) [i1 : Fintype G] [i2 : Group G]
namespace Group

lemma multiset_ne_zero : (@Fintype.elems G).val ≠ 0 := by
  have e : G := (i2.one)
  have h1 : e ∈ (@Fintype.elems G).val := Finset.mem_univ e
  have h2 : 0 < Multiset.card (@Fintype.elems G).val := by
    apply (Multiset.card_pos_iff_exists_mem).mpr
    exact Exists.intro e h1
  exact Multiset.card_pos.mp h2

end Group

lemma inv_pow_eq_card_sub_pow (g : G) (m : ℕ) (H : m ≤ Fintype.card G) :
  (g ^ m)⁻¹ = g^(Fintype.card G - m) := by
    have h : (g ^ m) * g ^ (Fintype.card G - m) = 1 := by
      rw [← pow_add]
      rw [Nat.add_sub_of_le]
      exact pow_card_eq_one
      exact H
    exact inv_eq_of_mul_eq_one_right h

-- The pow_eq_mod_card lemma is already implemented in mathlib
